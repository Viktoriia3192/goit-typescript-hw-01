"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startDevServer = void 0;
const dev_server_cli_1 = require("@web/dev-server-cli");
const chalk_1 = __importDefault(require("chalk"));
const nodeResolvePlugin_1 = require("./nodeResolvePlugin");
const watchPlugin_1 = require("./watchPlugin");
const esbuildPlugin_1 = require("./esbuildPlugin");
const cliOptions = [
    {
        name: 'preserve-symlinks',
        description: "Don't follow symlinks when resolving module imports.",
        type: Boolean,
    },
    {
        name: 'node-resolve',
        description: 'Resolve bare module imports using node resolution',
        type: Boolean,
    },
    {
        name: 'watch',
        alias: 'w',
        description: 'Reload the browser when files are changed.',
        type: Boolean,
    },
    {
        name: 'esbuild-target',
        type: String,
        multiple: true,
        description: 'JS language target to compile down to using esbuild. Recommended value is "auto", which compiles based on user agent. Check the docs for more options.',
    },
    {
        name: 'debug',
        description: 'Log debug messages.',
        type: Boolean,
    },
];
async function startDevServer(options = {}) {
    const { autoExitProcess = true, argv = process.argv, logStartMessage = true } = options;
    try {
        const cliArgs = dev_server_cli_1.readCliArgsConfig(cliOptions, argv);
        const cliArgsConfig = {};
        for (const [key, value] of Object.entries(cliArgs)) {
            // cli args are read from a file, they are validated by cli-options and later on as well
            cliArgsConfig[key] = value;
        }
        const config = await dev_server_cli_1.readConfig(Object.assign({ eventStream: true }, cliArgsConfig));
        const { rootDir } = config;
        if (typeof rootDir !== 'string') {
            throw new Error('No rootDir specified.');
        }
        if (!Array.isArray(config.plugins)) {
            config.plugins = [];
        }
        if (config.esbuildTarget) {
            config.plugins.push(esbuildPlugin_1.esbuildPlugin(config.esbuildTarget));
        }
        if (config.nodeResolve) {
            const userOptions = typeof config.nodeResolve === 'object' ? config.nodeResolve : undefined;
            config.plugins.push(nodeResolvePlugin_1.nodeResolvePlugin(rootDir, config.preserveSymlinks, userOptions));
        }
        if (config.watch) {
            config.plugins.push(watchPlugin_1.watchPlugin());
        }
        const validatedConfig = dev_server_cli_1.validateCoreConfig(config);
        return dev_server_cli_1.startDevServer(validatedConfig, {
            autoExitProcess,
            logStartMessage,
            clearTerminalOnChange: config.watch,
        });
    }
    catch (error) {
        console.error(chalk_1.default.red(`\nFailed to start dev server: ${error.message}\n`));
        process.exit(1);
    }
}
exports.startDevServer = startDevServer;
//# sourceMappingURL=startDevServer.js.map